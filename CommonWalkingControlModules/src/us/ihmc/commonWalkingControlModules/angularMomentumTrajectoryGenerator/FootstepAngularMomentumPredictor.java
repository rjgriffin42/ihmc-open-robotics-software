package us.ihmc.commonWalkingControlModules.angularMomentumTrajectoryGenerator;

import java.util.ArrayList;
import java.util.List;

import us.ihmc.commonWalkingControlModules.configurations.CoPPointName;
import us.ihmc.commonWalkingControlModules.instantaneousCapturePoint.smoothCMP.CoPPointsInFoot;
import us.ihmc.commons.PrintTools;
import us.ihmc.euclid.referenceFrame.FramePoint3D;
import us.ihmc.euclid.referenceFrame.FrameVector3D;
import us.ihmc.euclid.referenceFrame.ReferenceFrame;
import us.ihmc.graphicsDescription.yoGraphics.YoGraphicsList;
import us.ihmc.graphicsDescription.yoGraphics.plotting.ArtifactList;
import us.ihmc.robotics.math.frames.YoFramePoint;
import us.ihmc.robotics.math.frames.YoFrameVector;
import us.ihmc.robotics.math.trajectories.TrajectoryMathTools;
import us.ihmc.robotics.math.trajectories.YoFrameTrajectory3D;
import us.ihmc.robotics.math.trajectories.YoSegmentedFrameTrajectory3D;
import us.ihmc.robotics.math.trajectories.YoTrajectory;
import us.ihmc.robotics.referenceFrames.ReferenceFrame;
import us.ihmc.yoVariables.listener.VariableChangedListener;
import us.ihmc.yoVariables.registry.YoVariableRegistry;
import us.ihmc.yoVariables.variable.YoBoolean;
import us.ihmc.yoVariables.variable.YoDouble;
import us.ihmc.yoVariables.variable.YoInteger;
import us.ihmc.yoVariables.variable.YoVariable;

/**
 * Estimates the angular momentum generated by the swing foot about the CoM during a footstep
 * Needs a footstep CoP plan. Uses the entry, exit and end CoPs defined in the CoP plan to calculate a segmented CoM trajectory
 * The CoM trajectory is then used along with the footstep plan to determine the angular momentum generated
 */
public class FootstepAngularMomentumPredictor implements AngularMomentumTrajectoryGeneratorInterface
{
   private static final boolean DEBUG = true;

   private static final ReferenceFrame worldFrame = ReferenceFrame.getWorldFrame();
   private static final FrameVector3D zeroVector = new FrameVector3D();
   private final YoVariableRegistry registry = new YoVariableRegistry(getClass().getSimpleName());
   private final int maxNumberOfTrajectoryCoefficients = 7;
   private final int numberOfSwingSegments = 1;
   private final int numberOfTransferSegments = 2;
   private final int maxNumberOfFootstepsToConsider = 10;
   private final TrajectoryMathTools trajMathTools;

   private final YoBoolean computePredictedAngularMomentum;
   private final YoInteger numberOfFootstepsToConsider;
   private CoPPointName trajectoryInitialDepartureReference;
   private CoPPointName trajectoryFinalApproachReference;
   private CoPPointName entryCoPName;
   private CoPPointName endCoPName;

   private final YoDouble omega0;
   private final YoDouble gravityZ;
   private final YoDouble swingLegMass;
   private final YoDouble supportLegMass;
   private final YoDouble comHeight;
   private final YoDouble swingFootMaxHeight;

   private final List<CoPPointsInFoot> upcomingCoPsInFootsteps;
   private final YoInteger numberOfRegisteredFootsteps;

   private final List<SwingAngularMomentumTrajectory> swingAngularMomentumTrajectories;
   private final List<TransferAngularMomentumTrajectory> transferAngularMomentumTrajectories;

   private final FrameVector3D desiredAngularMomentum = new FrameVector3D();
   private final FrameVector3D desiredTorque = new FrameVector3D();
   private final FrameVector3D desiredRotatum = new FrameVector3D();

   //private final YoFrameTrajectory3D footstepCoMTrajectory;
   private final YoFrameTrajectory3D segmentCoMTrajectory;
   private final YoFrameTrajectory3D segmentCoMVelocity;
   private final YoFrameTrajectory3D swingFootTrajectory;
   private final YoTrajectory swingLiftTrajectory;
   private final YoFrameTrajectory3D swingFootVelocity;
   private final YoFrameTrajectory3D supportFootTrajectory;
   private final YoFrameTrajectory3D supportFootVelocity;
   private final YoFrameTrajectory3D estimatedAngularMomentumTrajectory;
   private final YoFrameTrajectory3D previousEstimatedTransferTrajectory; // needed to compute the first double support trajectory segment 
   private final FramePoint3D previousFinalReferenceCoP = new FramePoint3D();
   private AngularMomentumTrajectoryInterface activeTrajectory;
   private double initialTime;
   private double previousFirstTransferEndTime;
   private double currentFootstepTime;
   private double currentSwingSegmentDuration;
   private double currentFirstTransferSegmentDuration;
   private double currentSecondTransferSegmentDuration;

   private enum TrajectorySegment
   {
      END_TO_ENTRY, EXIT_TO_END, ENTRY_TO_EXIT
   };

   private final FramePoint3D tempFramePoint1 = new FramePoint3D(), tempFramePoint2 = new FramePoint3D(), tempFramePoint3 = new FramePoint3D(),
         tempFramePoint4 = new FramePoint3D();
   private final FrameVector3D tempFrameVector1 = new FrameVector3D(), tempFrameVector2 = new FrameVector3D();

   // DEBUGGING 
   private final YoFrameTrajectory3D swingTrajDebug;
   private final YoFrameTrajectory3D supportTrajDebug;
   private final YoFrameVector anguMomTrajDebug;
   private final YoFramePoint comPosDebug;
   private final YoFramePoint comVelDebug;
   private final YoFramePoint comAccDebug;
   private final YoFramePoint swingFootPosDebug;
   private final YoFramePoint swingFootVelDebug;
   private final YoFramePoint swingFootAccDebug;
   private final YoFramePoint supportFootPosDebug;
   private final YoFramePoint supportFootVelDebug;
   private final YoFramePoint supportFootAccDebug;
   private final List<TrajectoryDebug> transferCoMTrajectories;
   private final List<TrajectoryDebug> swingCoMTrajectories;
   private final List<TrajectoryDebug> transferSwingFootTrajectories;
   private final List<TrajectoryDebug> swingSwingFootTrajectories;
   private final List<TrajectoryDebug> transferSupportFootTrajectories;
   private final List<TrajectoryDebug> swingSupportFootTrajectories;
   private final YoFrameTrajectory3D comTrajDebug;
   private TrajectoryDebug activeCoMTrajectory;
   private TrajectoryDebug activeSwFootTrajectory;
   private TrajectoryDebug activeSpFootTrajectory;

   private int tempInt1;

   public FootstepAngularMomentumPredictor(String namePrefix, YoDouble omega0, YoVariableRegistry parentRegistry)
   {
      String fullPrefix = namePrefix + "AngularMomentum";
      this.trajMathTools = new TrajectoryMathTools(fullPrefix, 2 * maxNumberOfTrajectoryCoefficients, parentRegistry);
      this.computePredictedAngularMomentum = new YoBoolean(fullPrefix + "ComputePredictedAngularMomentum", registry);
      this.numberOfFootstepsToConsider = new YoInteger(fullPrefix + "MaxFootsteps", registry);
      this.omega0 = omega0;
      this.gravityZ = new YoDouble("AngularMomentumGravityZ", parentRegistry);
      omega0.addVariableChangedListener(new VariableChangedListener()
      {
         @Override
         public void variableChanged(YoVariable<?> v)
         {
            comHeight.set(gravityZ.getDoubleValue() / (omega0.getDoubleValue() * omega0.getDoubleValue()));
         }
      });
      gravityZ.addVariableChangedListener(new VariableChangedListener()
      {
         @Override
         public void variableChanged(YoVariable<?> v)
         {
            comHeight.set(gravityZ.getDoubleValue() / (omega0.getDoubleValue() * omega0.getDoubleValue()));
         }
      });
      this.swingLegMass = new YoDouble(fullPrefix + "SwingFootMass", registry);
      this.supportLegMass = new YoDouble(fullPrefix + "SupportFootMass", registry);
      this.comHeight = new YoDouble(fullPrefix + "CoMHeight", registry);
      
      this.swingFootMaxHeight = new YoDouble(fullPrefix + "SwingFootMaxHeight", registry);
      this.swingAngularMomentumTrajectories = new ArrayList<>(maxNumberOfFootstepsToConsider);
      this.transferAngularMomentumTrajectories = new ArrayList<>(maxNumberOfFootstepsToConsider + 1);

      if (DEBUG)
      {
         this.swingCoMTrajectories = new ArrayList<>(maxNumberOfFootstepsToConsider);
         this.transferCoMTrajectories = new ArrayList<>(maxNumberOfFootstepsToConsider + 1);
         this.swingSwingFootTrajectories = new ArrayList<>(maxNumberOfFootstepsToConsider);
         this.transferSwingFootTrajectories = new ArrayList<>(maxNumberOfFootstepsToConsider + 1);
         this.swingSupportFootTrajectories = new ArrayList<>(maxNumberOfFootstepsToConsider);
         this.transferSupportFootTrajectories = new ArrayList<>(maxNumberOfFootstepsToConsider + 1);
      }
      else
      {
         this.swingCoMTrajectories = null;
         this.transferCoMTrajectories = null;
         this.swingSwingFootTrajectories = null;
         this.transferSwingFootTrajectories = null;
         this.swingSupportFootTrajectories = null;
         this.transferSupportFootTrajectories = null;
      }

      this.upcomingCoPsInFootsteps = new ArrayList<>(maxNumberOfFootstepsToConsider + 2);
      this.numberOfRegisteredFootsteps = new YoInteger(fullPrefix + "NumberOfRegisteredFootsteps", registry);
      ReferenceFrame[] referenceFrames = {worldFrame};
      for (int i = 0; i < maxNumberOfFootstepsToConsider; i++)
      {
         SwingAngularMomentumTrajectory swingTrajectory = new SwingAngularMomentumTrajectory(namePrefix + "Footstep", i, registry, worldFrame,
                                                                                             numberOfSwingSegments, 2 * maxNumberOfTrajectoryCoefficients);
         this.swingAngularMomentumTrajectories.add(swingTrajectory);

         TransferAngularMomentumTrajectory transferTrajectory = new TransferAngularMomentumTrajectory(namePrefix + "Footstep", i, registry, worldFrame,
                                                                                                      numberOfTransferSegments,
                                                                                                      2 * maxNumberOfTrajectoryCoefficients);
         this.transferAngularMomentumTrajectories.add(transferTrajectory);
         CoPPointsInFoot copLocations = new CoPPointsInFoot(i, referenceFrames, registry);
         upcomingCoPsInFootsteps.add(copLocations);

         if (DEBUG)
         {
            TrajectoryDebug swingCoMTrajectory = new TrajectoryDebug("SwingCoMTrajDebug" + i, numberOfSwingSegments, maxNumberOfTrajectoryCoefficients,
                                                                     registry)
            {
            };
            swingCoMTrajectories.add(swingCoMTrajectory);
            TrajectoryDebug transferCoMTrajectory = new TrajectoryDebug("TransferCoMTrajDebug" + i, numberOfTransferSegments, maxNumberOfTrajectoryCoefficients,
                                                                        registry)
            {
            };
            transferCoMTrajectories.add(transferCoMTrajectory);
            TrajectoryDebug swingSwingFootTrajectory = new TrajectoryDebug("SwingSwFootTrajDebug" + i, numberOfSwingSegments, maxNumberOfTrajectoryCoefficients,
                                                                           registry)
            {
            };
            swingSwingFootTrajectories.add(swingSwingFootTrajectory);
            TrajectoryDebug transferSwingFootTrajectory = new TrajectoryDebug("TransferSwFootTrajDebug" + i, numberOfTransferSegments,
                                                                              maxNumberOfTrajectoryCoefficients, registry)
            {
            };
            transferSwingFootTrajectories.add(transferSwingFootTrajectory);
            TrajectoryDebug swingSupportFootTrajectory = new TrajectoryDebug("SwingSpFootTrajDebug" + i, numberOfSwingSegments,
                                                                             maxNumberOfTrajectoryCoefficients, registry)
            {
            };
            swingSupportFootTrajectories.add(swingSupportFootTrajectory);
            TrajectoryDebug transferSupportFootTrajectory = new TrajectoryDebug("TransferSpFootTrajDebug" + i, numberOfTransferSegments,
                                                                                maxNumberOfTrajectoryCoefficients, registry)
            {
            };
            transferSupportFootTrajectories.add(transferSupportFootTrajectory);
         }
      }
      CoPPointsInFoot copLocations = new CoPPointsInFoot(maxNumberOfFootstepsToConsider, referenceFrames, registry);
      upcomingCoPsInFootsteps.add(copLocations);
      copLocations = new CoPPointsInFoot(maxNumberOfFootstepsToConsider + 1, referenceFrames, registry);
      upcomingCoPsInFootsteps.add(copLocations);
      TransferAngularMomentumTrajectory transferTrajectory = new TransferAngularMomentumTrajectory(namePrefix + "Footstep", maxNumberOfFootstepsToConsider,
                                                                                                   registry, worldFrame, numberOfTransferSegments,
                                                                                                   2 * maxNumberOfTrajectoryCoefficients);
      this.transferAngularMomentumTrajectories.add(transferTrajectory);
      if (DEBUG)
      {
         TrajectoryDebug transferCoMTrajectory = new TrajectoryDebug("TransferCoMTrajDebug" + maxNumberOfFootstepsToConsider, numberOfTransferSegments,
                                                                     maxNumberOfTrajectoryCoefficients, registry)
         {
         };
         transferCoMTrajectories.add(transferCoMTrajectory);
         TrajectoryDebug transferSwingFootTrajectory = new TrajectoryDebug("TransferSwFootTrajDebug" + maxNumberOfFootstepsToConsider, numberOfTransferSegments,
                                                                           maxNumberOfTrajectoryCoefficients, registry)
         {
         };
         transferSwingFootTrajectories.add(transferSwingFootTrajectory);
         TrajectoryDebug transferSupportFootTrajectory = new TrajectoryDebug("TransferSpFootTrajDebug" + maxNumberOfFootstepsToConsider,
                                                                             numberOfTransferSegments, maxNumberOfTrajectoryCoefficients, registry)
         {
         };
         transferSupportFootTrajectories.add(transferSupportFootTrajectory);
      }

      this.segmentCoMTrajectory = new YoFrameTrajectory3D(namePrefix + "EstSegmentTrajectory", maxNumberOfTrajectoryCoefficients, worldFrame, registry);
      this.segmentCoMVelocity = new YoFrameTrajectory3D(namePrefix + "EstSegmentCoMVelocity", maxNumberOfTrajectoryCoefficients, worldFrame, registry);
      this.swingFootTrajectory = new YoFrameTrajectory3D(namePrefix + "EstSegmentSwingTrajectory", 2 * maxNumberOfTrajectoryCoefficients, worldFrame, registry);
      this.swingFootVelocity = new YoFrameTrajectory3D(namePrefix + "EstSegmentSwingVelocity", maxNumberOfTrajectoryCoefficients, worldFrame, registry);
      this.swingLiftTrajectory = new YoTrajectory(namePrefix + "SwingFootLiftTraj", maxNumberOfTrajectoryCoefficients, registry);
      this.supportFootTrajectory = new YoFrameTrajectory3D(namePrefix + "EstSegmentSupportTrajectory", 2 * maxNumberOfTrajectoryCoefficients, worldFrame,
                                                           registry);
      this.supportFootVelocity = new YoFrameTrajectory3D(namePrefix + "EstSegmentSupportVelocity", maxNumberOfTrajectoryCoefficients, worldFrame, registry);
      this.estimatedAngularMomentumTrajectory = new YoFrameTrajectory3D("EstSegmentAngularMomenetum", 2 * maxNumberOfTrajectoryCoefficients, worldFrame,
                                                                        registry);
      this.previousEstimatedTransferTrajectory = new YoFrameTrajectory3D(namePrefix + "SaveEstAngMomTraj", 2 * maxNumberOfTrajectoryCoefficients, worldFrame,
                                                                         registry);

      if (DEBUG)
      {
         this.anguMomTrajDebug = new YoFrameVector("AngMomViz", worldFrame, registry);
         this.comTrajDebug = new YoFrameTrajectory3D("CoMDebugTraj", 2 * maxNumberOfTrajectoryCoefficients, worldFrame, registry);
         this.swingTrajDebug = new YoFrameTrajectory3D("SwingDebugTraj", 2 * maxNumberOfTrajectoryCoefficients, worldFrame, registry);
         this.supportTrajDebug = new YoFrameTrajectory3D("SupportDebugTraj", 2 * maxNumberOfTrajectoryCoefficients, worldFrame, registry);
         this.comPosDebug = new YoFramePoint("CoMPosViz", "", worldFrame, registry);
         this.comVelDebug = new YoFramePoint("CoMVelViz", "", worldFrame, registry);
         this.comAccDebug = new YoFramePoint("CoMAccViz", "", worldFrame, registry);
         this.swingFootPosDebug = new YoFramePoint("SwFPosViz", worldFrame, registry);
         this.swingFootVelDebug = new YoFramePoint("SwFVelViz", worldFrame, registry);
         this.swingFootAccDebug = new YoFramePoint("SwFAccViz", worldFrame, registry);
         this.supportFootPosDebug = new YoFramePoint("SpFPosViz", worldFrame, registry);
         this.supportFootVelDebug = new YoFramePoint("SpFVelViz", worldFrame, registry);
         this.supportFootAccDebug = new YoFramePoint("SpFAccViz", worldFrame, registry);
      }
      else
      {
         comTrajDebug = null;
         swingTrajDebug = null;
         anguMomTrajDebug = null;
         comPosDebug = null;
         comVelDebug = null;
         comAccDebug = null;
         swingFootPosDebug = null;
         swingFootVelDebug = null;
         swingFootAccDebug = null;
         supportFootPosDebug = null;
         supportFootVelDebug = null;
         supportFootAccDebug = null;
      }

      parentRegistry.addChild(registry);
   }

   public void initializeParameters(AngularMomentumEstimationParameters angularMomentumParameters)
   {
      this.computePredictedAngularMomentum.set(angularMomentumParameters.computePredictedAngularMomentum());
      this.numberOfFootstepsToConsider.set(angularMomentumParameters.getNumberOfFootstepsToConsider());
      this.trajectoryInitialDepartureReference = angularMomentumParameters.getInitialDepartureReferenceName();
      this.trajectoryFinalApproachReference = angularMomentumParameters.getFinalApproachReferenceName();
      this.entryCoPName = angularMomentumParameters.getEntryCoPName();
      this.endCoPName = angularMomentumParameters.getEndCoPName();
      this.swingLegMass.set(angularMomentumParameters.getSwingLegMass());
      this.supportLegMass.set(angularMomentumParameters.getSupportLegMass());
      this.swingFootMaxHeight.set(angularMomentumParameters.getSwingFootMaxLift());
      this.gravityZ.set(angularMomentumParameters.getGravityZ());
   }

   @Override
   public void updateListeners()
   {
      // TODO Auto-generated method stub      
   }

   @Override
   public void createVisualizerForConstantAngularMomentum(YoGraphicsList yoGraphicsList, ArtifactList artifactList)
   {
      // TODO Auto-generated method stub
   }

   @Override
   public void clear()
   {
      for (int i = 0; i < maxNumberOfFootstepsToConsider; i++)
      {
         swingAngularMomentumTrajectories.get(i).reset();
         transferAngularMomentumTrajectories.get(i).reset();
         if (DEBUG)
         {
            swingCoMTrajectories.get(i).reset();
            transferCoMTrajectories.get(i).reset();
            swingSwingFootTrajectories.get(i).reset();
            transferSwingFootTrajectories.get(i).reset();
            swingSupportFootTrajectories.get(i).reset();
            transferSupportFootTrajectories.get(i).reset();
         }
      }
      if (DEBUG)
      {
         transferCoMTrajectories.get(maxNumberOfFootstepsToConsider).reset();
         transferSwingFootTrajectories.get(maxNumberOfFootstepsToConsider).reset();
         transferSupportFootTrajectories.get(maxNumberOfFootstepsToConsider).reset();
      }
      transferAngularMomentumTrajectories.get(maxNumberOfFootstepsToConsider).reset();
      for (int i = 0; i < upcomingCoPsInFootsteps.size(); i++)
         upcomingCoPsInFootsteps.get(i).reset();
   }

   public void addFootstepCoPsToPlan(List<CoPPointsInFoot> copLocations, int numberOfRegisteredFootsteps)
   {
      for (int i = 0; i < copLocations.size(); i++)
         upcomingCoPsInFootsteps.get(i).setIncludingFrame(copLocations.get(i));
      this.numberOfRegisteredFootsteps.set(numberOfRegisteredFootsteps);
   }

   @Override
   public void update(double currentTime)
   {
      if (activeTrajectory != null && computePredictedAngularMomentum.getBooleanValue())
         activeTrajectory.update(currentTime - initialTime, desiredAngularMomentum, desiredTorque, desiredRotatum);
      else
      {
         desiredAngularMomentum.setToZero();
         desiredTorque.setToZero();
         desiredRotatum.setToZero();
      }
   }

   @Override
   public void getDesiredAngularMomentum(FrameVector3D desiredAngMomToPack)
   {
      desiredAngMomToPack.setIncludingFrame(desiredAngularMomentum);
   }

   @Override
   public void getDesiredAngularMomentum(FrameVector3D desiredAngMomToPack, FrameVector3D desiredTorqueToPack)
   {
      desiredAngMomToPack.setIncludingFrame(desiredAngularMomentum);
      desiredTorqueToPack.setIncludingFrame(desiredTorque);
   }

   public void getDesiredAngularMomentum(FrameVector3D desiredAngMomToPack, FrameVector3D desiredTorqueToPack, FrameVector3D desiredRotatumToPack)
   {
      desiredAngMomToPack.setIncludingFrame(desiredAngularMomentum);
      desiredTorqueToPack.setIncludingFrame(desiredTorque);
      desiredRotatumToPack.setIncludingFrame(desiredRotatum);
   }

   @Override
   public void getDesiredAngularMomentum(YoFrameVector desiredAngMomToPack)
   {
      desiredAngMomToPack.set(desiredAngularMomentum);
   }

   @Override
   public void getDesiredAngularMomentum(YoFrameVector desiredAngMomToPack, YoFrameVector desiredTorqueToPack)
   {
      desiredAngMomToPack.set(desiredAngularMomentum);
      desiredTorqueToPack.set(desiredTorque);
   }

   public void getDesiredAngularMomentum(YoFrameVector desiredAngMomToPack, YoFrameVector desiredTorqueToPack, YoFrameVector desiredRotatumToPack)
   {
      desiredAngMomToPack.set(desiredAngularMomentum);
      desiredTorqueToPack.set(desiredTorque);
      desiredRotatumToPack.set(desiredRotatum);
   }

   @Override
   public void initializeForTransfer(double currentTime)
   {
      initialTime = currentTime;
      activeTrajectory = transferAngularMomentumTrajectories.get(0);
      if (DEBUG)
      {
         activeCoMTrajectory = transferCoMTrajectories.get(0);
         activeSwFootTrajectory = transferSwingFootTrajectories.get(0);
         activeSpFootTrajectory = transferSupportFootTrajectories.get(0);
      }
   }

   @Override
   public void initializeForSwing(double currentTime)
   {
      initialTime = currentTime;
      activeTrajectory = swingAngularMomentumTrajectories.get(0);
      if (DEBUG)
      {
         activeCoMTrajectory = swingCoMTrajectories.get(0);
         activeSwFootTrajectory = swingSwingFootTrajectories.get(0);
         activeSpFootTrajectory = swingSupportFootTrajectories.get(0);
      }
   }

   private double additionalInitialSwingTime = 0.0;

   @Override
   public void computeReferenceAngularMomentumStartingFromDoubleSupport(boolean atAStop)
   {
      int footstepIndex = 0;

      if (!computePredictedAngularMomentum.getBooleanValue())
         return;
      else if (atAStop && numberOfRegisteredFootsteps.getIntegerValue() == 0)
      {
         // Set all segments of one transfer angular momentum trajectories to zero as this is only a transfer trajectory 
         double segmentStartTime = 0.0;
         upcomingCoPsInFootsteps.get(footstepIndex).get(0).getPosition(tempFramePoint1);
         for (int i = 0; i < upcomingCoPsInFootsteps.get(footstepIndex + 1).getCoPPointList().size(); i++)
         {
            upcomingCoPsInFootsteps.get(footstepIndex + 1).get(i).getPosition(tempFramePoint2);
            transferAngularMomentumTrajectories.get(footstepIndex).set(segmentStartTime,
                                                                       segmentStartTime + upcomingCoPsInFootsteps.get(footstepIndex + 1).get(i).getTime(),
                                                                       tempFramePoint1, tempFramePoint2);
            tempFramePoint1.setIncludingFrame(tempFramePoint2);
            segmentStartTime += upcomingCoPsInFootsteps.get(footstepIndex + 1).get(i).getTime();
         }
         return;
      }

      if (atAStop)
      {
         upcomingCoPsInFootsteps.get(footstepIndex).get(0).getPosition(previousFinalReferenceCoP);
         previousFirstTransferEndTime = 0.0;
         updateCurrentSegmentTimes(footstepIndex);
         currentSecondTransferSegmentDuration += upcomingCoPsInFootsteps.get(footstepIndex + 1).get(0).getTime();
         currentFootstepTime += upcomingCoPsInFootsteps.get(footstepIndex + 1).get(0).getTime();
         additionalInitialSwingTime = upcomingCoPsInFootsteps.get(footstepIndex + 1).get(0).getTime();
         computeAngularMomentumApproximationForFootstep(footstepIndex);
         footstepIndex++;
      }
      else
      {
         additionalInitialSwingTime = 0.0;
         upcomingCoPsInFootsteps.get(footstepIndex).get(CoPPlanningTools.getCoPPointIndex(upcomingCoPsInFootsteps.get(footstepIndex).getCoPPointList(),
                                                                                          trajectoryFinalApproachReference))
                                .getPosition(previousFinalReferenceCoP);
         transferAngularMomentumTrajectories.get(footstepIndex).set(previousEstimatedTransferTrajectory);
         previousFirstTransferEndTime = previousEstimatedTransferTrajectory.getFinalTime();
         if (DEBUG)
         {
            transferCoMTrajectories.get(footstepIndex).set(comTrajDebug);
            transferSwingFootTrajectories.get(footstepIndex).set(swingTrajDebug);
            transferSupportFootTrajectories.get(footstepIndex).set(supportTrajDebug);
         }
         
      }
      computeAngularMomentumApproximationForUpcomingFootsteps(footstepIndex);
   }

   @Override
   public void computeReferenceAngularMomentumStartingFromSingleSupport()
   {
      if (!computePredictedAngularMomentum.getBooleanValue())
         return;

      int footstepIndex = 0;
      previousFirstTransferEndTime = 0.0;
      updateCurrentSegmentTimes(footstepIndex);
      currentSecondTransferSegmentDuration += additionalInitialSwingTime;
      currentFootstepTime += additionalInitialSwingTime;
      computeAngularMomentumApproximationForFootstep(footstepIndex);
      previousEstimatedTransferTrajectory.set(transferAngularMomentumTrajectories.get(footstepIndex + 1).getSegment(0));
      comTrajDebug.set(transferCoMTrajectories.get(footstepIndex + 1).getSegment(0));
      swingTrajDebug.set(transferSwingFootTrajectories.get(footstepIndex + 1).getSegment(0));
      supportTrajDebug.set(transferSupportFootTrajectories.get(footstepIndex + 1).getSegment(0));
      footstepIndex++;
      computeAngularMomentumApproximationForUpcomingFootsteps(footstepIndex);
   }

   private void computeAngularMomentumApproximationForUpcomingFootsteps(int footstepIndex)
   {
      int numberOfFootstepsToPlan = Math.min(numberOfRegisteredFootsteps.getIntegerValue(), numberOfFootstepsToConsider.getIntegerValue());
      //for (; footstepIndex + 2 < upcomingCoPsInFootsteps.size() && (upcomingCoPsInFootsteps.get(footstepIndex + 1).getCoPPointList().size() > 1); footstepIndex++)
      for (; footstepIndex + 2 < upcomingCoPsInFootsteps.size() && (footstepIndex < numberOfFootstepsToPlan); footstepIndex++)
      {
         updateCurrentSegmentTimes(footstepIndex);
         computeAngularMomentumApproximationForFootstep(footstepIndex);
      }
   }

   // This function assumes that all setup for the footstep has been carried out already 
   private void computeAngularMomentumApproximationForFootstep(int footstepIndex)
   {
      computeAngularMomentumApproximationForFootstep(TrajectorySegment.END_TO_ENTRY, footstepIndex);
   }

   private void computeAngularMomentumApproximationForFootstep(TrajectorySegment startFromSegment, int footstepIndex)
   {
      switch (startFromSegment)
      {
      case END_TO_ENTRY:
         computeAngularMomentumForSecondTransferSegment(footstepIndex);
      case ENTRY_TO_EXIT:
         computeAngularMomentumForSwing(footstepIndex);
      default:
         computeAngularMomentumForFirstTransfer(footstepIndex);
      }
      previousFirstTransferEndTime = currentFirstTransferSegmentDuration;
   }

   private void computeAngularMomentumForSecondTransferSegment(int footstepIndex)
   {
      setCoMTrajectoryForSecondTransfer(footstepIndex, previousFirstTransferEndTime);
      //PrintTools.debug("Transfer2: " + segmentCoMTrajectory.toString());
      setSwingFootTrajectoryForSecondTransfer(footstepIndex, previousFirstTransferEndTime);
      setSupportFootTrajectoryForSecondTransfer(footstepIndex, previousFirstTransferEndTime);
      calculateAngularMomentumTrajectory();
      transferAngularMomentumTrajectories.get(footstepIndex).set(estimatedAngularMomentumTrajectory);
   }

   private void computeAngularMomentumForSwing(int footstepIndex)
   {
      setCoMTrajectoryForSwing(footstepIndex);
      //PrintTools.debug("Swing: " + segmentCoMTrajectory.toString());
      setSwingFootTrajectoryForSwing(footstepIndex);
      setSupportFootTrajectoryForSwing(footstepIndex);
      calculateAngularMomentumTrajectory();
      swingAngularMomentumTrajectories.get(footstepIndex).set(estimatedAngularMomentumTrajectory);
   }

   private void computeAngularMomentumForFirstTransfer(int footstepIndex)
   {
      setCoMTrajectoryForFirstTransfer(footstepIndex);
      //PrintTools.debug("Transfer1: " + segmentCoMTrajectory.toString());
      setSwingFootTrajectoryForFirstTransfer(footstepIndex);
      setSupportFootTrajectoryForFirstTransfer(footstepIndex);
      calculateAngularMomentumTrajectory();
      transferAngularMomentumTrajectories.get(footstepIndex + 1).set(estimatedAngularMomentumTrajectory);
   }
   
   private void calculateAngularMomentumTrajectory()
   {
      trajMathTools.subtract(swingFootTrajectory, swingFootTrajectory, segmentCoMTrajectory);
      trajMathTools.subtract(swingFootVelocity, swingFootVelocity, segmentCoMVelocity);
      trajMathTools.subtract(supportFootTrajectory, supportFootTrajectory, segmentCoMTrajectory);
      trajMathTools.subtract(supportFootVelocity, supportFootTrajectory, segmentCoMVelocity);

      trajMathTools.crossProduct(swingFootTrajectory, swingFootTrajectory, swingFootVelocity);
      trajMathTools.scale(swingFootTrajectory, swingFootTrajectory, swingLegMass.getDoubleValue());
      trajMathTools.crossProduct(supportFootTrajectory, supportFootTrajectory, supportFootVelocity);
      trajMathTools.scale(supportFootTrajectory, supportFootTrajectory, supportLegMass.getDoubleValue());

      trajMathTools.add(estimatedAngularMomentumTrajectory, supportFootTrajectory, swingFootTrajectory);
   }

   private void setSupportFootTrajectoryForSwing(int footstepIndex)
   {
      setSupportFootTrajectory(footstepIndex, 0.0, currentSwingSegmentDuration);
      if(DEBUG)
         swingSupportFootTrajectories.get(footstepIndex).set(supportFootTrajectory);
   }

   private void setSupportFootTrajectoryForFirstTransfer(int footstepIndex)
   {
      setSupportFootTrajectory(footstepIndex, 0.0, currentFirstTransferSegmentDuration);
      if(DEBUG)
         transferSupportFootTrajectories.get(footstepIndex + 1).set(supportFootTrajectory);
   }

   private void setSupportFootTrajectoryForSecondTransfer(int footstepIndex, double segmentStartTime)
   {
      setSupportFootTrajectory(footstepIndex, segmentStartTime, segmentStartTime + currentSecondTransferSegmentDuration);
      if(DEBUG)
         transferSupportFootTrajectories.get(footstepIndex).set(supportFootTrajectory);
   }

   private void setSupportFootTrajectory(int footstepIndex, double startTime, double endTime)
   {
      upcomingCoPsInFootsteps.get(footstepIndex + 1).getSupportFootLocation(tempFramePoint1);
      supportFootTrajectory.setConstant(startTime, endTime, tempFramePoint1);
      trajMathTools.getDerivative(supportFootVelocity, supportFootTrajectory);
   }

   private void setSwingFootTrajectoryForSwing(int footstepIndex)
   {
      upcomingCoPsInFootsteps.get(footstepIndex).getSupportFootLocation(tempFramePoint1);
      upcomingCoPsInFootsteps.get(footstepIndex + 1).getSwingFootLocation(tempFramePoint2);
      swingFootTrajectory.setPenticWithZeroTerminalAcceleration(0.0, currentSwingSegmentDuration, tempFramePoint1, zeroVector, tempFramePoint2, zeroVector);
      updateSwingLiftTrajectory();
      trajMathTools.getDerivative(swingFootVelocity, swingFootTrajectory);

      if (DEBUG)
         swingSwingFootTrajectories.get(footstepIndex).set(swingFootTrajectory);
   }
   
   private void updateSwingLiftTrajectory()
   {
      swingLiftTrajectory.setQuadraticUsingIntermediatePoint(0, currentSwingSegmentDuration / 2.0, currentSwingSegmentDuration, 0.0,
                                                             swingFootMaxHeight.getDoubleValue(), 0.0);
   }

   // First transfer - exitCoP to endCoP
   // Second transfer - endCoP to entry CoP
   private void setSwingFootTrajectoryForFirstTransfer(int footstepIndex)
   {
      upcomingCoPsInFootsteps.get(footstepIndex + 1).getSwingFootLocation(tempFramePoint1);
      swingFootTrajectory.setConstant(0.0, currentFirstTransferSegmentDuration, tempFramePoint1);
      trajMathTools.getDerivative(swingFootVelocity, swingFootTrajectory);

      if (DEBUG)
         transferSwingFootTrajectories.get(footstepIndex + 1).set(swingFootTrajectory);
   }

   private void setSwingFootTrajectoryForSecondTransfer(int footstepIndex, double segmentStartTime)
   {
      upcomingCoPsInFootsteps.get(footstepIndex).getSupportFootLocation(tempFramePoint1);
      swingFootTrajectory.setConstant(segmentStartTime, segmentStartTime + currentSecondTransferSegmentDuration, tempFramePoint1);
      trajMathTools.getDerivative(swingFootVelocity, swingFootTrajectory);

      if (DEBUG)
         transferSwingFootTrajectories.get(footstepIndex).set(swingFootTrajectory);
   }

   private void setCoMTrajectoryForSwing(int footstepIndex)
   {
      getCoMEstimationWaypoints(footstepIndex);
      segmentCoMTrajectory.setPenticWithZeroTerminalAcceleration(-currentSecondTransferSegmentDuration,
                                                                 -currentSecondTransferSegmentDuration + currentFootstepTime, tempFramePoint1, tempFrameVector1,
                                                                 tempFramePoint2, tempFrameVector2);
      segmentCoMTrajectory.setTime(0.0, currentSwingSegmentDuration);
      trajMathTools.getDerivative(segmentCoMVelocity, segmentCoMTrajectory);

      if (DEBUG)
         swingCoMTrajectories.get(footstepIndex).set(segmentCoMTrajectory);
   }

   private void setCoMTrajectoryForFirstTransfer(int footstepIndex)
   {
      getCoMEstimationWaypoints(footstepIndex);
      segmentCoMTrajectory.setPenticWithZeroTerminalAcceleration(-(currentSecondTransferSegmentDuration + currentSwingSegmentDuration),
                                                                 currentFirstTransferSegmentDuration, tempFramePoint1, tempFrameVector1, tempFramePoint2,
                                                                 tempFrameVector2);
      segmentCoMTrajectory.setTime(0.0, currentFirstTransferSegmentDuration);
      trajMathTools.getDerivative(segmentCoMVelocity, segmentCoMTrajectory);

      if (DEBUG)
         transferCoMTrajectories.get(footstepIndex + 1).set(segmentCoMTrajectory);
   }

   private void setCoMTrajectoryForSecondTransfer(int footstepIndex, double startTime)
   {
      getCoMEstimationWaypoints(footstepIndex);
      segmentCoMTrajectory.setPenticWithZeroTerminalAcceleration(startTime, startTime + currentFootstepTime, tempFramePoint1, tempFrameVector1, tempFramePoint2,
                                                                 tempFrameVector2);
      segmentCoMTrajectory.setTime(startTime, startTime + currentSecondTransferSegmentDuration);
      trajMathTools.getDerivative(segmentCoMVelocity, segmentCoMTrajectory);

      if (DEBUG)
         transferCoMTrajectories.get(footstepIndex).set(segmentCoMTrajectory);
   }

   private void getCoMEstimationWaypoints(int footstepIndex)
   {
      upcomingCoPsInFootsteps.get(footstepIndex).getSwingFootLocation(tempFramePoint3);
      upcomingCoPsInFootsteps.get(footstepIndex).getSupportFootLocation(tempFramePoint4);
      tempFramePoint1.interpolate(tempFramePoint3, tempFramePoint4, 0.5);
      upcomingCoPsInFootsteps.get(footstepIndex + 1).getSwingFootLocation(tempFramePoint3);
      upcomingCoPsInFootsteps.get(footstepIndex + 1).getSupportFootLocation(tempFramePoint4);
      tempFramePoint2.interpolate(tempFramePoint3, tempFramePoint4, 0.5);

      if (footstepIndex == 0)
      {
         upcomingCoPsInFootsteps.get(footstepIndex + 1).get(CoPPlanningTools.getCoPPointIndex(upcomingCoPsInFootsteps.get(footstepIndex + 1).getCoPPointList(),
                                                                                              trajectoryInitialDepartureReference))
                                .getPosition(tempFramePoint3);
         tempFrameVector1.sub(tempFramePoint3, previousFinalReferenceCoP);
      }
      else
      {
         upcomingCoPsInFootsteps.get(footstepIndex + 1).get(CoPPlanningTools.getCoPPointIndex(upcomingCoPsInFootsteps.get(footstepIndex + 1).getCoPPointList(),
                                                                                              trajectoryInitialDepartureReference))
                                .getPosition(tempFramePoint3);
         upcomingCoPsInFootsteps.get(footstepIndex).get(CoPPlanningTools.getCoPPointIndex(upcomingCoPsInFootsteps.get(footstepIndex).getCoPPointList(),
                                                                                          trajectoryFinalApproachReference))
                                .getPosition(tempFramePoint4);
         tempFrameVector1.sub(tempFramePoint3, tempFramePoint4);
      }

      //if(footstepIndex + 3 < upcomingCoPsInFootsteps.size() && !upcomingCoPsInFootsteps.get(footstepIndex + 3).getCoPPointList().isEmpty())
      if (footstepIndex + 1 < Math.min(numberOfRegisteredFootsteps.getIntegerValue(), numberOfFootstepsToConsider.getIntegerValue()))
      {
         upcomingCoPsInFootsteps.get(footstepIndex + 1).get(CoPPlanningTools.getCoPPointIndex(upcomingCoPsInFootsteps.get(footstepIndex + 1).getCoPPointList(),
                                                                                              trajectoryFinalApproachReference))
                                .getPosition(tempFramePoint3);
         upcomingCoPsInFootsteps.get(footstepIndex + 2).get(CoPPlanningTools.getCoPPointIndex(upcomingCoPsInFootsteps.get(footstepIndex + 2).getCoPPointList(),
                                                                                              trajectoryInitialDepartureReference))
                                .getPosition(tempFramePoint4);
         tempFrameVector2.sub(tempFramePoint4, tempFramePoint3);
      }
      else
      {
         upcomingCoPsInFootsteps.get(footstepIndex + 1).get(CoPPlanningTools.getCoPPointIndex(upcomingCoPsInFootsteps.get(footstepIndex + 1).getCoPPointList(),
                                                                                              trajectoryFinalApproachReference))
                                .getPosition(tempFramePoint3);
         tempFrameVector2.sub(tempFramePoint2, tempFramePoint3);
      }
      tempFramePoint1.add(0, 0, comHeight.getDoubleValue());
      tempFramePoint2.add(0, 0, comHeight.getDoubleValue());
   }

   CoPPointName searchCoPName;

   private void updateCurrentSegmentTimes(int footstepIndex)
   {
      this.currentFootstepTime = 0.0;
      CoPPointsInFoot currentCoPPlanReference = upcomingCoPsInFootsteps.get(footstepIndex + 1);
      List<CoPPointName> currentCoPListReference = currentCoPPlanReference.getCoPPointList();
      if (currentCoPListReference.isEmpty())
      {
         PrintTools.debug("Encountered empty list ");
         return;
      }
      currentSecondTransferSegmentDuration = 0.0;
      for (tempInt1 = CoPPlanningTools.getCoPPointIndex(currentCoPListReference, endCoPName)
            + 1; currentCoPListReference.get(tempInt1) != entryCoPName; tempInt1++)
         currentSecondTransferSegmentDuration += currentCoPPlanReference.get(tempInt1).getTime();
      currentSecondTransferSegmentDuration += currentCoPPlanReference.get(tempInt1).getTime();
      tempInt1++;
      currentSwingSegmentDuration = 0.0;
      for (; tempInt1 < currentCoPListReference.size(); tempInt1++)
         currentSwingSegmentDuration += currentCoPPlanReference.get(tempInt1).getTime();
      currentFirstTransferSegmentDuration = 0.0;
      currentCoPPlanReference = upcomingCoPsInFootsteps.get(footstepIndex + 2);
      currentCoPListReference = currentCoPPlanReference.getCoPPointList();
      searchCoPName = (numberOfRegisteredFootsteps.getIntegerValue() < numberOfFootstepsToConsider.getIntegerValue()
            && footstepIndex == numberOfRegisteredFootsteps.getIntegerValue() - 1) ? CoPPointName.FINAL_COP : endCoPName;
      for (tempInt1 = 0; currentCoPListReference.get(tempInt1) != searchCoPName; tempInt1++)
         currentFirstTransferSegmentDuration += currentCoPPlanReference.get(tempInt1).getTime();

      currentFirstTransferSegmentDuration += currentCoPPlanReference.get(tempInt1).getTime();
      currentFootstepTime = currentSecondTransferSegmentDuration + currentSwingSegmentDuration + currentFirstTransferSegmentDuration;
   }

   FramePoint3D tempFramePointForCoMPosDebug = new FramePoint3D();
   FrameVector3D tempFramePointForCoMVelDebug = new FrameVector3D();
   FrameVector3D tempFramePointForCoMAccDebug = new FrameVector3D();

   public void getPredictedCenterOfMassPosition(YoFramePoint pointToPack, double time)
   {
      if (DEBUG && computePredictedAngularMomentum.getBooleanValue())
      {
         activeCoMTrajectory.update(time - initialTime, tempFramePointForCoMPosDebug, tempFramePointForCoMVelDebug, tempFramePointForCoMAccDebug);
         pointToPack.set(tempFramePointForCoMPosDebug);
         comPosDebug.set(tempFramePointForCoMPosDebug);
         comVelDebug.set(tempFramePointForCoMVelDebug);
         comAccDebug.set(tempFramePointForCoMAccDebug);
      }
   }

   
   FramePoint3D tempFramePointForSwFootPosDebug = new FramePoint3D();
   FrameVector3D tempFramePointForSwFootVelDebug = new FrameVector3D();
   FrameVector3D tempFramePointForSwFootAccDebug = new FrameVector3D();
   FramePoint3D tempFramePointForSpFootPosDebug = new FramePoint3D();
   FrameVector3D tempFramePointForSpFootVelDebug = new FrameVector3D();
   FrameVector3D tempFramePointForSpFootAccDebug = new FrameVector3D();

   public void getPredictedSwingFootPosition(YoFramePoint pointToPack, double time)
   {
      if (DEBUG && computePredictedAngularMomentum.getBooleanValue())
      {
         activeSwFootTrajectory.update(time - initialTime, tempFramePointForSwFootPosDebug, tempFramePointForSwFootVelDebug, tempFramePointForSwFootAccDebug);
         pointToPack.set(tempFramePointForSwFootPosDebug);
         swingFootPosDebug.set(tempFramePointForSwFootPosDebug);
         swingFootVelDebug.set(tempFramePointForSwFootVelDebug);
         swingFootAccDebug.set(tempFramePointForSwFootAccDebug);
         activeSpFootTrajectory.update(time - initialTime, tempFramePointForSpFootPosDebug, tempFramePointForSpFootVelDebug, tempFramePointForSpFootAccDebug);
         supportFootPosDebug.set(tempFramePointForSpFootPosDebug);
         supportFootVelDebug.set(tempFramePointForSpFootVelDebug);
         supportFootAccDebug.set(tempFramePointForSpFootAccDebug);
      }
   }

   @Override
   public List<? extends AngularMomentumTrajectory> getTransferAngularMomentumTrajectories()
   {
      if (computePredictedAngularMomentum.getBooleanValue())
         return transferAngularMomentumTrajectories;
      else
         return null;
   }

   @Override
   public List<? extends AngularMomentumTrajectory> getSwingAngularMomentumTrajectories()
   {
      if (computePredictedAngularMomentum.getBooleanValue())
         return swingAngularMomentumTrajectories;
      else
         return null;
   }

   private class TrajectoryDebug extends YoSegmentedFrameTrajectory3D
   {

      public TrajectoryDebug(String name, int maxNumberOfSegments, int maxNumberOfCoefficients, YoVariableRegistry registry)
      {
         super(name, maxNumberOfSegments, maxNumberOfCoefficients, registry);
      }

      public void set(YoFrameTrajectory3D trajToCopy)
      {
         segments.get(getNumberOfSegments()).set(trajToCopy);
         numberOfSegments.increment();
      }
   }
}
