package us.ihmc.robotics.hierarchicalKinematics;

import org.ejml.data.DenseMatrix64F;
import us.ihmc.robotics.dataStructures.Vector64F;
import us.ihmc.robotics.geometry.RigidBodyTransform;

import javax.vecmath.Quat4d;
import javax.vecmath.Vector3d;

/**
 * ForwardKinematicSolver is used to calculate forward kinematic of a RobotModel.
 * <p>
 * Wrapper around the file generated by SWIG, i.e. ForwardKinematicSolverSwig.
 * This might look ugly but since we are not supposed to modify that generated file,
 * it is the only way to make a well documented class and to manage elegantly type conversion.
 * <p>
 * In particular, we don't want VectorXd and MatrixXd to pollute the rest of the code
 * For consistency DenseMatrix64F, Vector64F, Vector3d and Quat3d should be used instead.
 */

public class ForwardKinematicSolver {
   
   final private ForwardKinematicSolverSwig impl;
   private Vector64F lastQ;
   private VectorXd  tempVector;

   private boolean[] relevantJoints;
   private MatrixXd jacobian;
   private MatrixXd jacobianCOM;

   private VectorXd posX   = new VectorXd(3);
   private VectorXd quatX = new VectorXd(4);
   
   private Quat4d   quat4d = new Quat4d();
   private Vector3d vect3d = new Vector3d();

   public synchronized void delete() {
      impl.delete();
   }

   public ForwardKinematicSolver(RobotModel model_) 
   {
      impl  = new ForwardKinematicSolverSwig( model_);
      int nrOfJoints = model_.getNrOfJoints();
      
      tempVector  = new VectorXd( nrOfJoints );
      lastQ       = new Vector64F( nrOfJoints );
      relevantJoints = new boolean[ nrOfJoints ];
      jacobian    = new MatrixXd(6, nrOfJoints );
      jacobianCOM = new MatrixXd(3, nrOfJoints );
   }


   /**
    * Update the state of each of the links (bodies) of the robot, using the joint angles.
    * Note that the root link of the robot will be located in the origin of the coordinate system.
    *
    * @param Q is the ordered vector of joint angles needed to compute the forward kinematics.
    * 
    */
   public void updateKinematics(Vector64F Q) {
      convert( Q, tempVector);
      lastQ.set(Q);
      impl.updateKinematics(tempVector);
   }

   /**
    * Compute the jacobian matrix relative to a point. 
    * <p> 
    * The position of the point is relative to a specific body (most of the time the end effector)
    * and can have additionally a position offset. 
    * To be sure that the jacobian is up to date you should have called updateKinematics() first.
    * <p>
    * For example, if we want to calculate the jacobian 
    * of a simple robotic arm, the coordinate frame of the last body in the kinematic chain will be located 
    * in the "wrist"; the pointOffset can help us to control instead the center of the gripper that will be,
    * of course, displaced.
    *
    * @param bodyId         the body id. use RobotModel.getBodyId(name) to find it.
    * @param pointOffset    offset of the application point from the coordinate system of the given body.
    * @param outputJacobianMatrix is where the output is stored. It must be [6 X numJoints]. 
    *                             The upper half refer to position, the lower one to rotation.
    */
   public void computeJacobian(int bodyId, Vector3d pointOffset, DenseMatrix64F outputJacobianMatrix) {
      convert( pointOffset, posX);
      impl.computeJacobian(bodyId, posX, jacobian);
      convert( jacobian, outputJacobianMatrix);
   }

   /**
    * Compute the jacobian of the Center of Mass.
    * <p>
    * To be sure that the jacobian is up to date you should have called updateKinematics() first.
    *
    * @param outputJacobianCOM the output, that must be  [3 X numJoints]
    */
   public void computeJacobianCOM(DenseMatrix64F outputJacobianCOM) {
      impl.computeJacobianCOM( jacobianCOM );
      convert( jacobianCOM, outputJacobianCOM);
   }

   public int getNumberOfJoints() {
      return impl.getNumberOfJoints();
   }

   /**
    * Gets the position of the center of mass relative to the root of the robot kinematic chain.
    *
    * @param output the center of mass.
    */
   public void getCOM(Vector3d output) {
      VectorXd com = impl.getCOM();
      output.set( com.get(0),   com.get(1),  com.get(2));
   }

   public Vector64F getLastQ() {
      return lastQ;
   }

   /**
    * Gets the pose of a body. 
    * <p>
    * To update this value you should call updateKinematics() first.
    *
    * @param bodyId            the body id.
    * @param outputRotation    the output rotation.
    * @param outputOrigin      the output origin of the coordinate system.
    * @throws RuntimeException if the body with identifier bodyId was not found.
    */
   public void getBodyPose(int bodyId, Quat4d outputRotation, Vector3d outputOrigin) throws RuntimeException {

     impl.getBodyPose(bodyId, quatX, posX);

     convert( posX, outputOrigin);
     outputRotation.set( quatX.get(0), quatX.get(1), quatX.get(2), quatX.get(3));

     outputRotation.inverse();
   }

   /**
    * Gets the pose of a body.
    * <p>
    * To update this value you should call updateKinematics() first.
    *
    * @param bodyId            the body id.
    * @param outputTransform   the output transform.
    * @throws RuntimeException if the body with identifier bodyId was not found.
    */
   public void getBodyPose(int bodyId, RigidBodyTransform outputTransform) throws RuntimeException {
      
      getBodyPose(bodyId, quat4d, vect3d);
      outputTransform.set(quat4d, vect3d);
   }

   /**
    * Given a body, recursively move back on the kinematic chain and find all the joints which
    * contribute to the motion of this body.
    * <p>
    * For example, if we have a two armed robot and we pass the Id of the right arm, none of the joints 
    * of the left arm will be relevant.
    *
    * @param bodyId the body id
    * @return an ordered list of the relevant joints. "true" means relevant.
    */
   public boolean[] getRelevantJoints(int bodyId) 
   {
      tempVector = impl.getRelevantJoints(bodyId);
      for( int i=0; i< relevantJoints.length; i++)
      {
         relevantJoints[i] = tempVector.get(i) > 0;
      }
      return relevantJoints;
   }
   
   static private void convert(MatrixXd src, DenseMatrix64F dst)
   {
      for (int col=0; col < src.cols(); col++){
         for (int row=0; row < src.rows(); row++){
            dst.set(row,col, src.get(row, col));
         }
      }
   }
   
   static private void convert(Vector3d src, VectorXd dst)
   {
      dst.set(0, src.x );
      dst.set(1, src.y );
      dst.set(2, src.z );
   }
   
   static private void convert(VectorXd src, Vector3d dst)
   {
      dst.x = src.get(0); 
      dst.y = src.get(1);
      dst.z = src.get(2);
   }
   
   static private void convert(Vector64F src, VectorXd dst)
   {
      for( int i=0; i< src.numRows; i++) {
         dst.set(i, src.get(i));
      }
   }
   

   

}
