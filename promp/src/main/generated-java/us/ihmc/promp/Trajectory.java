// Targeted by JavaCPP version 1.5.7: DO NOT EDIT THIS FILE

package us.ihmc.promp;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static us.ihmc.promp.global.promp.*;


    /**
     * \brief  Class that represents a multidimensional trajectory.
     * A trajectory is described by the values at each timestep and the speed parameter.
     * speed indicates how the trajectory has been modulated, 
     * for example speed=2 means that the original trajectory had twice the timesteps.
     */
    @Namespace("promp") @Properties(inherit = us.ihmc.promp.presets.PrompInfoMapper.class)
public class Trajectory extends Pointer {
        static { Loader.load(); }
        /** Default native constructor. */
        public Trajectory() { super((Pointer)null); allocate(); }
        /** Native array allocator. Access with {@link Pointer#position(long)}. */
        public Trajectory(long size) { super((Pointer)null); allocateArray(size); }
        /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
        public Trajectory(Pointer p) { super(p); }
        private native void allocate();
        private native void allocateArray(long size);
        @Override public Trajectory position(long position) {
            return (Trajectory)super.position(position);
        }
        @Override public Trajectory getPointer(long i) {
            return new Trajectory((Pointer)this).offsetAddress(i);
        }
    
        
        /**
         *  \brief default constructor. Build empty trajectory.
         */

        /**
         *  \brief constructor that build a trajectory starting from data and speed
         *  \param data Eigen::Matrix containing the raw data, each column is a different dof
         *  \param speed speed of the original trajectory (time-scale factor: e.g., 2.0 to go from 200 time-steps to 100 time-steps)
         */

        /**
         *  \brief return number of dimensions of the trajectory
         */

        /**
         *  \brief return number of timesteps in the trajectory
         */

        /**
         *  \brief return the trajectory' speed
         */

        /**
         *  \brief return the raw data as Eigen::Matrix
         */
        public native @Const @ByRef EigenMatrixXd matrix();

        /**
         *  \brief return monodimensional trajectory from the selected dimension
         *  \param dim  dimension used to create the returned trajectory
         */

        /**
         *  \brief return  trajectory using data from the selected dimensions
         *  \param dim  list of dimensions used to create the returned trajectory
         */

        /**
         *  \brief modulate the trajectory to the desired number of timesteps
         *  Adjust speed according to speed = this->speed() * this->timesteps() / timesteps
         *  \param timesteps  desired number of steps in the trajectory
         */

        /**
         *  \brief create a new modulated trajectory with the desired number of timesteps
         *  Adjust its speed according to speed = this->speed() * this->timesteps() / timesteps
         *  \param timesteps  desired number of steps in the trajectory
         */

        /**
         *  \brief compute the Euclidean distance between this and a second trajectory
         *  \param other   trajectory used to compute the distance with
         *  \param modulate  if false the distance is computed using data until the smaller trajectory lenght,
         *  if true the other trajectory is modulated to this trajectory length before computing the distance
         */

        /**
         *  \brief infer the speed of a trajectory starting from the raw data
         *  \param obs_traj  data from whoch speed is inferred, comparing it to this trajectory
         *  \param lb  lower bound for inferred speed 
         *  \param ub  upper bound for inferred speed
         *  \param steps  number of speeds to be tested (linspace(lb, ub, steps))
         */
    }
