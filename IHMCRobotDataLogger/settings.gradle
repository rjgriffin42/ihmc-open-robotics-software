/**
 * This file performs the following 2 operations:
 *
 * Setup source sets as projects to correct inconsistent classpaths
 * across IDEs and Gradle. From "extraSourceSets" property.
 *
 * Parse this project's build.gradle for dependencies in group "us.ihmc"
 * and recursively search for those builds on disk and include them as
 * composite builds.
 *
 * This file is needed until Gradle implements the following features:
 * - Allow nested composite builds (https://github.com/gradle/gradle/issues/1909)
 *
 * THIS FILE IS AUTO-GENERATED BY THE IHMC BUILD GRADLE PLUGIN
 * To disable auto-generation, set "disableSettingsGeneration = true"
 * in the gradle.properties file.
 */
import org.codehaus.groovy.ast.ASTNode
import org.codehaus.groovy.ast.CodeVisitorSupport
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.ast.expr.*
import org.codehaus.groovy.control.MultipleCompilationErrorsException

import java.nio.file.Files
import java.nio.file.NoSuchFileException
import java.nio.file.Path

rootProject.name = hyphenatedName
logger.info("[ihmc-build] Evaluating " + pascalCasedName + " settings.gradle")

// SETUP SOURCE SETS AS PROJECTS

Eval.me(extraSourceSets).each {
   new File(rootProject.projectDir, it).mkdir()
   include it
   project(":" + it).name = hyphenatedName + "-" + it
}

// SEARCH FOR BUILDS ON DISK TO INCLUDE

if (startParameter.searchUpwards)
{
   def assembler = new IHMCCompositeBuildAssembler(rootProject, logger, Integer.valueOf(workspaceDirectoryLevel))
   assembler.findCompositeBuilds().forEach {
      includeBuild it
   }
}

// HELPER CLASS AND METHODS

class IHMCCompositeBuildAssembler
{
   private final ProjectDescriptor rootProject;
   private final Logger logger;

   private Path rootProjectPath
   private Path workspacePath
   private Map<String, String> projectNameReplacements
   private Map<String, Path> buildFolderNameToPathMap
   private Set<String> transitiveBuildFolderKeys

   public IHMCCompositeBuildAssembler(ProjectDescriptor rootProject, Logger logger, int workspaceDirectoryLevel)
   {
      this.rootProject = rootProject
      this.logger = logger

      rootProjectPath = rootProject.projectDir.toPath()
      workspacePath = rootProjectPath
      for (int i = 0; i < workspaceDirectoryLevel; i++)
      {
         workspacePath = workspacePath.resolve("..")
      }
      workspacePath = workspacePath.toRealPath()
      projectNameReplacements = projectNameReplacements()
      buildFolderNameToPathMap = new HashMap<String, Path>()
      transitiveBuildFolderKeys = new TreeSet<String>()
   }

   public List<String> findCompositeBuilds()
   {
      logger.info("[ihmc-build] Workspace dir: " + workspacePath)
      mapDirectory(workspacePath)
      buildFolderNameToPathMap.keySet().forEach {
         logger.info("[ihmc-build] Found: " + it + " : " + buildFolderNameToPathMap.get(it))
      }

      List<String> buildsToInclude = new ArrayList<>()
      findTransitivesRecursive(rootProjectPath)
      for (String transitiveKey : transitiveBuildFolderKeys)
      {
         if (!loadPropertiesAndDetermineIfItsExcluded(buildFolderNameToPathMap.get(transitiveKey)))
         {
            String relativizedPathName = rootProjectPath.relativize(buildFolderNameToPathMap.get(transitiveKey)).toString()
            if (!relativizedPathName.isEmpty()) // Including itself
            {
               buildsToInclude.add(relativizedPathName)
            }
         }
      }

      for (String buildToInclude : buildsToInclude)
      {
         logger.quiet("[ihmc-build] Including build: " + buildToInclude)
      }

      return buildsToInclude
   }

   private boolean loadPropertiesAndDetermineIfItsExcluded(Path projectPath)
   {
      Properties properties = new Properties()
      properties.load(new FileInputStream(projectPath.resolve("gradle.properties").toFile()))
      for (String propertyKey : properties.keySet())
      {
         if (propertyKey == "excludeFromCompositeBuild" && properties.get(propertyKey) == "true")
         {
            logger.quiet("[ihmc-build] Excluding " + projectPath.fileName.toString() + ". Propertry excludeFromCompositeBuild = " + properties.get(propertyKey))
            return true
         }
      }

      return false
   }

   private void findTransitivesRecursive(Path projectDir)
   {
      SortedSet<String> dependencies = parseDependenciesFromGradleFile(projectDir.resolve("build.gradle"))

      dependencies.each {
         List<String> newMatchingKeys = findMatchingBuildKey(it)

         transitiveBuildFolderKeys.addAll(newMatchingKeys)
         for (String newMatchingKey : newMatchingKeys)
         {
            logger.info("[ihmc-build] Adding module: " + newMatchingKey)
            findTransitivesRecursive(buildFolderNameToPathMap.get(newMatchingKey))
         }
      }
   }

   private List<String> findMatchingBuildKey(String hyphenatedName)
   {
      List<String> matched = new ArrayList<>();
      for (String folderName : buildFolderNameToPathMap.keySet())
      {
         if (!transitiveBuildFolderKeys.contains(folderName) && matchNames(folderName, hyphenatedName))
         {
            logger.info("Matched: " + hyphenatedName + " to " + folderName + "  " + hyphenatedToPascalCased(hyphenatedName))
            matched.add(folderName)
         }
      }

      return matched
   }

   private void mapDirectory(Path directory)
   {
      Files.list(directory).forEach {
         if (Files.isDirectory(it) && Files.exists(it.resolve("build.gradle")))
         {
            buildFolderNameToPathMap.put(it.fileName.toString(), it)
            mapDirectory(it)
         }
      }
   }

   private boolean matchNames(String directoryName, String buildName)
   {
      if (directoryName == buildName) return true
      if (directoryName == hyphenatedToPascalCased(buildName)) return true

      if (buildName.contains("-"))
      {
         String possibleMainProject = buildName.substring(0, buildName.lastIndexOf("-"))
         if (possibleMainProject != buildName)
         {
            if (directoryName == possibleMainProject) return true
            if (directoryName == hyphenatedToPascalCased(possibleMainProject)) return true
         }
      }

      return false
   }

   private SortedSet<String> parseDependenciesFromGradleFile(Path buildFile)
   {
      SortedSet<String> dependencySet = new TreeSet<String>()
      try
      {
         AstBuilder builder = new AstBuilder()
         def bytesInFile = new String(Files.readAllBytes(buildFile))
         logger.info("[ihmc-build] Parsing for dependencies: " + buildFile)
         List<ASTNode> nodes = builder.buildFromString(bytesInFile)
         List<String[]> dependencies = new ArrayList<>()
         def visitor = codeVisitor(dependencies)
         for (ASTNode node : nodes)
         {
            node.visit(visitor)
         }

         dependencies.each {
            if (it[0] == "us.ihmc")
            {
               logger.info("[ihmc-build] Found declared us.ihmc dependency: " + it[1])
               dependencySet.add(it[1])
            }
         }
      }
      catch (NoSuchFileException e)
      {
         logger.info("[ihmc-build] Build not found on disk: " + e.getMessage())
      }
      catch (GradleScriptException e)
      {
         logger.error("[ihmc-build] Cannot evaluate " + buildFile + ": " + e.getMessage())
      }
      catch (MultipleCompilationErrorsException e)
      {
         logger.error("[ihmc-build] Cannot evaluate " + buildFile + ": " + e.getMessage())
      }
      catch (IOException e)
      {
         logger.error(e.printStackTrace())
      }
      return dependencySet
   }

   private CodeVisitorSupport codeVisitor(dependencies)
   {
      return new CodeVisitorSupport() {
         @Override
         public void visitArgumentlistExpression(ArgumentListExpression ale)
         {
            List<Expression> expressions = ale.getExpressions()

            if (expressions.size() == 1 && expressions.get(0) instanceof ConstantExpression)
            {
               String dependencyString = expressions.get(0).getText()
               if (dependencyString.contains(":"))
               {
                  String[] split = dependencyString.split(":")

                  if (split.length >= 3)
                  {
                     dependencies.add([split[0], split[1], split[2]])
                  }
               }
            }

            super.visitArgumentlistExpression(ale)
         }

         @Override
         public void visitMapExpression(MapExpression expression)
         {
            logger.info("[ihmc-build] Found map entry: " + expression.getText())
            List<MapEntryExpression> mapEntryExpressions = expression.getMapEntryExpressions()
            if (mapEntryExpressions.size() >= 3)
            {
               Map<String, String> dependencyMap = new HashMap<String, String>()

               for (MapEntryExpression mapEntryExpression : mapEntryExpressions)
               {
                  String key = mapEntryExpression.getKeyExpression().getText()
                  String value = mapEntryExpression.getValueExpression().getText()
                  dependencyMap.put(key, value)
               }

               dependencies.add([dependencyMap.get("group"), dependencyMap.get("name"), dependencyMap.get("version")])
            }

            super.visitMapExpression(expression)
         }
      }
   }

   private String hyphenatedToPascalCased(String hyphenated)
   {
      String[] split = hyphenated.split("-")
      String pascalCased = ""
      for (String section : split)
      {
         if (projectNameReplacements.containsKey(section))
         {
            pascalCased += projectNameReplacements.get(section)
         } else
         {
            pascalCased += capitalize(section)
         }
      }
      return pascalCased
   }

   private String capitalize(final String str)
   {
      int strLen
      if (str == null || (strLen = str.length()) == 0)
      {
         return str
      }

      final char firstChar = str.charAt(0)
      if (Character.isTitleCase(firstChar))
      {
         return str
      }

      return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString()
   }

   private Map<String, String> projectNameReplacements()
   {
      def projectNameReplacements = [:]
      projectNameReplacements["ihmc"] = "IHMC"
      projectNameReplacements["vt"] = "VT"
      projectNameReplacements["javafx"] = "JavaFX"
      projectNameReplacements["jmonkey"] = "JMonkey"
      projectNameReplacements["ros"] = "ROS"
      projectNameReplacements["ros1"] = "ROS1"
      projectNameReplacements["ros2"] = "ROS2"
      projectNameReplacements["lla"] = "LLA"
      projectNameReplacements["devops"] = "DevOps"
      projectNameReplacements["ejml"] = "EJML"
      projectNameReplacements["icub"] = "ICub"
      projectNameReplacements["dds"] = "DDS"
      projectNameReplacements["rtps"] = "RTPS"
      projectNameReplacements["sri"] = "SRI"
      projectNameReplacements["ethercat"] = "EtherCAT"
      projectNameReplacements["imu"] = "IMU"
      projectNameReplacements["icp"] = "ICP"
      projectNameReplacements["it"] = "IT"
      projectNameReplacements["ipxe"] = "IPXE"
      projectNameReplacements["aot"] = "AOT"
      projectNameReplacements["joctomap"] = "JOctoMap"
      projectNameReplacements["mav"] = "MAV"
      projectNameReplacements["megabots"] = "MegaBots"
      projectNameReplacements["megabot"] = "MegaBot"
      return projectNameReplacements
   }
}