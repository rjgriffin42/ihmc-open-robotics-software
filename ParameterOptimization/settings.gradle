/**
 * This file performs the following 2 operations:
 *
 * Setup source sets as projects to correct inconsistent classpaths
 * across IDEs and Gradle. From "extraSourceSets" property.
 *
 * Parse this project's build.gradle for dependencies in group "us.ihmc"
 * and recursively search for those builds on disk and include them as
 * composite builds.
 *
 * This file is needed until Gradle implements the following features:
 * - Allow nested composite builds (https://github.com/gradle/gradle/issues/1909)
 *
 * THIS FILE IS AUTO-GENERATED BY THE IHMC BUILD GRADLE PLUGIN
 * To disable auto-generation, set "disableSettingsGeneration = true"
 * in the gradle.properties file.
 */
import org.codehaus.groovy.ast.ASTNode
import org.codehaus.groovy.ast.CodeVisitorSupport
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.ast.expr.*
import org.codehaus.groovy.control.MultipleCompilationErrorsException

import java.nio.file.Files
import java.nio.file.NoSuchFileException
import java.nio.file.Path

rootProject.name = hyphenatedName
logger.info("[ihmc-build] Evaluating " + pascalCasedName + " settings.gradle")

// SETUP SOURCE SETS AS PROJECTS

Eval.me(extraSourceSets).each {
   new File(rootProject.projectDir, it).mkdir()
   include it
   project(":" + it).name = hyphenatedName + "-" + it
}

// SEARCH FOR BUILDS ON DISK TO INCLUDE

if (Boolean.valueOf(automaticallyIncludeBuilds) == true && startParameter.searchUpwards)
{
   def assembler = new IHMCCompositeBuildAssembler(rootProject, logger, Integer.valueOf(workspaceDirectoryLevel))
   assembler.findCompositeBuilds().forEach {
      includeBuild it
   }
}

// HELPER CLASS AND METHODS

class IHMCCompositeBuildAssembler
{
   private final ProjectDescriptor rootProject;
   private final Logger logger;

   private Path rootProjectPath
   private Path workspacePath
   private Map<String, Path> buildFolderNameToPathMap
   private Map<String, BuildProperties> buildFolderNameToPropertiesMap
   private Set<String> transitiveBuildFolderNames

   public IHMCCompositeBuildAssembler(ProjectDescriptor rootProject, Logger logger, int workspaceDirectoryLevel)
   {
      this.rootProject = rootProject
      this.logger = logger

      rootProjectPath = rootProject.projectDir.toPath()
      workspacePath = rootProjectPath
      for (int i = 0; i < workspaceDirectoryLevel; i++)
      {
         workspacePath = workspacePath.resolve("..")
      }
      workspacePath = workspacePath.toRealPath()
      buildFolderNameToPathMap = new HashMap<String, Path>()
      buildFolderNameToPropertiesMap = new HashMap<String, BuildProperties>()
      transitiveBuildFolderNames = new TreeSet<String>()
   }

   public List<String> findCompositeBuilds()
   {
      logger.info("[ihmc-build] Workspace dir: " + workspacePath)
      mapDirectory(workspacePath)
      buildFolderNameToPathMap.keySet().forEach {
         logger.info("[ihmc-build] Found: " + it + " : " + buildFolderNameToPathMap.get(it))
      }

      List<String> buildsToInclude = new ArrayList<>()
      findTransitivesRecursive(rootProjectPath)
      for (String transitiveKey : transitiveBuildFolderNames)
      {
         if (!buildFolderNameToPropertiesMap.get(transitiveKey).exclude)
         {
            String relativizedPathName = rootProjectPath.relativize(buildFolderNameToPathMap.get(transitiveKey)).toString()
            if (!relativizedPathName.isEmpty()) // Including itself
            {
               buildsToInclude.add(relativizedPathName)
            }
         }
      }

      for (String buildToInclude : buildsToInclude)
      {
         logger.quiet("[ihmc-build] Including build: " + buildToInclude)
      }

      return buildsToInclude
   }

   private void findTransitivesRecursive(Path projectDir)
   {
      SortedSet<String> dependencies = parseDependenciesFromGradleFile(projectDir.resolve("build.gradle"))

      dependencies.each {
         List<String> newMatchingKeys = findMatchingBuildKey(it)

         transitiveBuildFolderNames.addAll(newMatchingKeys)
         for (String newMatchingKey : newMatchingKeys)
         {
            logger.info("[ihmc-build] Adding module: " + newMatchingKey)
            findTransitivesRecursive(buildFolderNameToPathMap.get(newMatchingKey))
         }
      }
   }

   private List<String> findMatchingBuildKey(String dependencyNameAsDeclared)
   {
      List<String> matched = new ArrayList<>();
      for (String buildFolderNameToCheck : buildFolderNameToPathMap.keySet())
      {
         if (!transitiveBuildFolderNames.contains(buildFolderNameToCheck) && matchNames(buildFolderNameToCheck, dependencyNameAsDeclared))
         {
            logger.info("Matched: " + dependencyNameAsDeclared + " to " + buildFolderNameToCheck + "  " + toPascalCased(dependencyNameAsDeclared))
            matched.add(buildFolderNameToCheck)
         }
      }

      return matched
   }

   private void mapDirectory(Path directory)
   {
      Files.list(directory).forEach {
         if (Files.isDirectory(it) && Files.exists(it.resolve("build.gradle")))
         {
            buildFolderNameToPathMap.put(it.fileName.toString(), it)
            buildFolderNameToPropertiesMap.put(it.fileName.toString(), loadProperties(it))

            mapDirectory(it)
         }
      }
   }

   private BuildProperties loadProperties(Path projectPath)
   {
      Properties properties = new Properties()
      properties.load(new FileInputStream(projectPath.resolve("gradle.properties").toFile()))
      BuildProperties buildProperties = new BuildProperties()
      for (String propertyKey : properties.keySet())
      {
         if (propertyKey == "excludeFromCompositeBuild")
         {
            buildProperties.exclude = Boolean.valueOf(properties.get(propertyKey))
            if (buildProperties.exclude)
            {
               logger.quiet("[ihmc-build] Excluding " + projectPath.fileName.toString() + ". Property excludeFromCompositeBuild = " + properties.get(propertyKey))
            }
         }
         if (propertyKey == "pascalCasedName")
         {
            buildProperties.pascalCasedName = properties.get(propertyKey)
         }
         if (propertyKey == "hyphenatedName")
         {
            buildProperties.hyphenatedName = properties.get(propertyKey)
         }
         if (propertyKey == "extraSourceSets")
         {
            buildProperties.extraSourceSets.addAll(Eval.me(properties.get(propertyKey)))
         }
      }

      if (buildProperties.pascalCasedName == null)
      {
         buildProperties.pascalCasedName = toPascalCased(projectPath.fileName.toString())
      }
      if (buildProperties.hyphenatedName == null)
      {
         buildProperties.hyphenatedName = toHyphenated(projectPath.fileName.toString())
      }

      return buildProperties
   }

   private class BuildProperties
   {
      String hyphenatedName = null
      String pascalCasedName = null
      boolean exclude = false
      List<String> extraSourceSets = new ArrayList<String>()
   }

   private boolean matchNames(String buildFolderNameToCheck, String dependencyNameAsDeclared)
   {
      if (dependencyNameAsDeclared == buildFolderNameToCheck) return true

      BuildProperties buildToCheckProperties = buildFolderNameToPropertiesMap.get(buildFolderNameToCheck)

      if (dependencyNameAsDeclared == buildToCheckProperties.pascalCasedName) return true
      if (dependencyNameAsDeclared == buildToCheckProperties.hyphenatedName) return true

      for (String extraSourceSet : buildToCheckProperties.extraSourceSets)
      {
         if (dependencyNameAsDeclared == buildToCheckProperties.pascalCasedName + extraSourceSet.capitalize()) return true
         if (dependencyNameAsDeclared == buildToCheckProperties.hyphenatedName + "-" + extraSourceSet) return true
      }

      return false
   }

   private SortedSet<String> parseDependenciesFromGradleFile(Path buildFile)
   {
      SortedSet<String> dependencySet = new TreeSet<String>()
      try
      {
         AstBuilder builder = new AstBuilder()
         def bytesInFile = new String(Files.readAllBytes(buildFile))
         logger.info("[ihmc-build] Parsing for dependencies: " + buildFile)
         List<ASTNode> nodes = builder.buildFromString(bytesInFile)
         List<String[]> dependencies = new ArrayList<>()
         def visitor = codeVisitor(dependencies)
         for (ASTNode node : nodes)
         {
            node.visit(visitor)
         }

         dependencies.each {
            if (it[0] == "us.ihmc")
            {
               logger.info("[ihmc-build] Found declared us.ihmc dependency: " + it[1])
               dependencySet.add(it[1])
            }
         }
      }
      catch (NoSuchFileException e)
      {
         logger.info("[ihmc-build] Build not found on disk: " + e.getMessage())
      }
      catch (GradleScriptException e)
      {
         logger.error("[ihmc-build] Cannot evaluate " + buildFile + ": " + e.getMessage())
      }
      catch (MultipleCompilationErrorsException e)
      {
         logger.error("[ihmc-build] Cannot evaluate " + buildFile + ": " + e.getMessage())
      }
      catch (IOException e)
      {
         logger.error(e.printStackTrace())
      }
      return dependencySet
   }

   private CodeVisitorSupport codeVisitor(dependencies)
   {
      return new CodeVisitorSupport() {
         @Override
         public void visitArgumentlistExpression(ArgumentListExpression ale)
         {
            List<Expression> expressions = ale.getExpressions()

            if (expressions.size() == 1 && expressions.get(0) instanceof ConstantExpression)
            {
               String dependencyString = expressions.get(0).getText()
               if (dependencyString.contains(":"))
               {
                  String[] split = dependencyString.split(":")

                  if (split.length >= 3)
                  {
                     dependencies.add([split[0], split[1], split[2]])
                  }
               }
            }

            super.visitArgumentlistExpression(ale)
         }

         @Override
         public void visitMapExpression(MapExpression expression)
         {
            logger.info("[ihmc-build] Found map entry: " + expression.getText())
            List<MapEntryExpression> mapEntryExpressions = expression.getMapEntryExpressions()
            if (mapEntryExpressions.size() >= 3)
            {
               Map<String, String> dependencyMap = new HashMap<String, String>()

               for (MapEntryExpression mapEntryExpression : mapEntryExpressions)
               {
                  String key = mapEntryExpression.getKeyExpression().getText()
                  String value = mapEntryExpression.getValueExpression().getText()
                  dependencyMap.put(key, value)
               }

               dependencies.add([dependencyMap.get("group"), dependencyMap.get("name"), dependencyMap.get("version")])
            }

            super.visitMapExpression(expression)
         }
      }
   }

   private String toPascalCased(String hyphenated)
   {
      String[] split = hyphenated.split("-")
      String pascalCased = ""
      for (String section : split)
      {
         pascalCased += capitalize(section)
      }
      return pascalCased
   }

   private String toHyphenated(String pascalCased)
   {
      String hyphenated = pascalCasedToPrehyphenated(pascalCased);

      hyphenated = hyphenated.substring(1, hyphenated.length() - 1);

      return hyphenated;
   }

   private String pascalCasedToPrehyphenated(String pascalCased)
   {
      List<String> parts = new ArrayList<>();
      String part = "";

      for (int i = 0; i < pascalCased.length(); i++)
      {
         String character = String.valueOf(pascalCased.charAt(i));
         if (isAllUpperCase(character) || isNumeric(character))
         {
            if (!part.isEmpty())
            {
               parts.add(part.toLowerCase());
            }
            part = character;
         } else
         {
            part += character;
         }
      }
      if (!part.isEmpty())
      {
         parts.add(part.toLowerCase());
      }

      String hyphenated = "";
      for (int i = 0; i < parts.size(); i++)
      {
         hyphenated += '-';
         hyphenated += parts.get(i);
      }
      hyphenated += '-';

      return hyphenated;
   }

   private String capitalize(final String str)
   {
      int strLen
      if (str == null || (strLen = str.length()) == 0)
      {
         return str
      }

      final char firstChar = str.charAt(0)
      if (Character.isTitleCase(firstChar))
      {
         return str
      }

      return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString()
   }

   private boolean isAllUpperCase(final CharSequence cs)
   {
      if (cs == null || isEmpty(cs))
      {
         return false;
      }
      final int sz = cs.length();
      for (int i = 0; i < sz; i++)
      {
         if (Character.isUpperCase(cs.charAt(i)) == false)
         {
            return false;
         }
      }
      return true;
   }

   private boolean isNumeric(final CharSequence cs)
   {
      if (isEmpty(cs))
      {
         return false;
      }
      final int sz = cs.length();
      for (int i = 0; i < sz; i++)
      {
         if (Character.isDigit(cs.charAt(i)) == false)
         {
            return false;
         }
      }
      return true;
   }

   private boolean isEmpty(final CharSequence cs)
   {
      return cs == null || cs.length() == 0;
   }
}