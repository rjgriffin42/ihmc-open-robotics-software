package object_manipulation_msgs;

public interface PickupGoal extends org.ros.internal.message.Message {
  static final java.lang.String _TYPE = "object_manipulation_msgs/PickupGoal";
  static final java.lang.String _DEFINITION = "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n# An action for picking up an object\n\n# which arm to be used for grasping\nstring arm_name\n\n# the object to be grasped\nGraspableObject target\n\n# a list of grasps to be used\n# if empty, the grasp executive will call one of its own planners\nGrasp[] desired_grasps\n\n# how the object should be lifted after the grasp\n# the frame_id that this lift is specified in MUST be either the robot_frame \n# or the gripper_frame specified in your hand description file\nGripperTranslation lift\n\n# the name that the target object has in the collision map\n# can be left empty if no name is available\nstring collision_object_name\n\n# the name that the support surface (e.g. table) has in the collision map\n# can be left empty if no name is available\nstring collision_support_surface_name\n\n# whether collisions between the gripper and the support surface should be acceptable\n# during move from pre-grasp to grasp and during lift. Collisions when moving to the\n# pre-grasp location are still not allowed even if this is set to true.\nbool allow_gripper_support_collision\n\n# whether reactive grasp execution using tactile sensors should be used\nbool use_reactive_execution\n\n# whether reactive object lifting based on tactile sensors should be used\nbool use_reactive_lift\n\n# set this to true if you only want to query the manipulation pipeline as to what \n# grasps it thinks are feasible, without actually executing them. If this is set to \n# true, the atempted_grasp_results field of the result will be populated, but no arm \n# movement will be attempted\nbool only_perform_feasibility_test\n\n# set this to true if you want to ignore all collisions throughout the pickup \n# and also move directly to the pre-grasp using Cartesian controllers\nbool ignore_collisions\n\n# OPTIONAL (These will not have to be filled out most of the time)\n# constraints to be imposed on every point in the motion of the arm\narm_navigation_msgs/Constraints path_constraints\n\n# OPTIONAL (These will not have to be filled out most of the time)\n# additional collision operations to be used for every arm movement performed\n# during grasping. Note that these will be added on top of (and thus overide) other \n# collision operations that the grasping pipeline deems necessary. Should be used\n# with care and only if special behaviors are desired\narm_navigation_msgs/OrderedCollisionOperations additional_collision_operations\n\n# OPTIONAL (These will not have to be filled out most of the time)\n# additional link paddings to be used for every arm movement performed\n# during grasping. Note that these will be added on top of (and thus overide) other \n# link paddings that the grasping pipeline deems necessary. Should be used\n# with care and only if special behaviors are desired\narm_navigation_msgs/LinkPadding[] additional_link_padding\n\n# an optional list of obstacles that we have semantic information about\n# and that can be moved in the course of grasping\nGraspableObject[] movable_obstacles\n\n# the maximum contact force to use while grasping (<=0 to disable)\nfloat32 max_contact_force\n\n";
  java.lang.String getArmName();
  void setArmName(java.lang.String value);
  object_manipulation_msgs.GraspableObject getTarget();
  void setTarget(object_manipulation_msgs.GraspableObject value);
  java.util.List<object_manipulation_msgs.Grasp> getDesiredGrasps();
  void setDesiredGrasps(java.util.List<object_manipulation_msgs.Grasp> value);
  object_manipulation_msgs.GripperTranslation getLift();
  void setLift(object_manipulation_msgs.GripperTranslation value);
  java.lang.String getCollisionObjectName();
  void setCollisionObjectName(java.lang.String value);
  java.lang.String getCollisionSupportSurfaceName();
  void setCollisionSupportSurfaceName(java.lang.String value);
  boolean getAllowGripperSupportCollision();
  void setAllowGripperSupportCollision(boolean value);
  boolean getUseReactiveExecution();
  void setUseReactiveExecution(boolean value);
  boolean getUseReactiveLift();
  void setUseReactiveLift(boolean value);
  boolean getOnlyPerformFeasibilityTest();
  void setOnlyPerformFeasibilityTest(boolean value);
  boolean getIgnoreCollisions();
  void setIgnoreCollisions(boolean value);
  arm_navigation_msgs.Constraints getPathConstraints();
  void setPathConstraints(arm_navigation_msgs.Constraints value);
  arm_navigation_msgs.OrderedCollisionOperations getAdditionalCollisionOperations();
  void setAdditionalCollisionOperations(arm_navigation_msgs.OrderedCollisionOperations value);
  java.util.List<arm_navigation_msgs.LinkPadding> getAdditionalLinkPadding();
  void setAdditionalLinkPadding(java.util.List<arm_navigation_msgs.LinkPadding> value);
  java.util.List<object_manipulation_msgs.GraspableObject> getMovableObstacles();
  void setMovableObstacles(java.util.List<object_manipulation_msgs.GraspableObject> value);
  float getMaxContactForce();
  void setMaxContactForce(float value);
}
