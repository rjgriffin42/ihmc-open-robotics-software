/**
 * This file performs the following 2 operations:
 *
 * Setup source sets as projects to correct inconsistent classpaths
 * across IDEs and Gradle. From "extraSourceSets" property.
 *
 * Parse this project's build.gradle for dependencies in group "us.ihmc"
 * and recursively search for those builds on disk and include them as
 * composite builds.
 *
 * This file is needed until Gradle implements the following features:
 * - Allow nested composite builds (https://github.com/gradle/gradle/issues/1909)
 *
 * THIS FILE IS AUTO-GENERATED BY THE IHMC BUILD GRADLE PLUGIN
 * To disable auto-generation, set "disableSettingsGeneration = true"
 * in the gradle.properties file.
 */
import org.codehaus.groovy.ast.ASTNode
import org.codehaus.groovy.ast.CodeVisitorSupport
import org.codehaus.groovy.ast.builder.AstBuilder
import org.codehaus.groovy.ast.expr.*
import org.codehaus.groovy.control.MultipleCompilationErrorsException

import java.nio.file.Files
import java.nio.file.NoSuchFileException

rootProject.name = hyphenatedName
logger.info("[ihmc-build] Evaluating " + pascalCasedName + " settings.gradle")

// SETUP SOURCE SETS AS PROJECTS

Eval.me(extraSourceSets).each {
   new File(rootProject.projectDir, it).mkdir()
   include it
   project(":" + it).name = hyphenatedName + "-" + it
}

// SEARCH FOR BUILDS ON DISK TO INCLUDE

if (startParameter.searchUpwards)
{
   workspaceDirectoryLevel = Integer.valueOf(workspaceDirectoryLevel)

   def projectPath = rootProject.projectDir.toPath()
   def workspaceDirectory = projectPath
   for (int i = 0; i < workspaceDirectoryLevel; i++)
   {
      workspaceDirectory = workspaceDirectory.resolve("..")
   }

   workspaceDirectory = workspaceDirectory.toRealPath()
   logger.info("[ihmc-build] Workspace dir: " + workspaceDirectory)
   def buildNameToPathMap = new HashMap<String, java.nio.file.Path>()
   mapDirectory(workspaceDirectory, buildNameToPathMap)

   buildNameToPathMap.keySet().forEach {
      logger.info("[ihmc-build] Found: " + it + " : " + buildNameToPathMap.get(it))
   }

   def transitiveKeys = new TreeSet<String>()
   findTransitivesRecursive(projectPath, transitiveKeys, buildNameToPathMap, projectNameReplacements())
   for (String transitiveKey : transitiveKeys)
   {
      def relativizedPathName = projectPath.relativize(buildNameToPathMap.get(transitiveKey)).toString()
      logger.quiet("[ihmc-build] Including build: " + relativizedPathName)
      includeBuild relativizedPathName
   }
}

// HELPER METHODS

void findTransitivesRecursive(java.nio.file.Path projectDir,
                              TreeSet<String> transitiveKeys,
                              Map<String, java.nio.file.Path> buildNameToPathMap,
                              Map<String, String> projectNameReplacements)
{
   SortedSet<String> dependencies = parseDependenciesFromGradleFile(projectDir.resolve("build.gradle"))

   dependencies.each {
      String matchingKey = findMatchingBuildKey(it, buildNameToPathMap, projectNameReplacements)

      if (matchingKey != null && !transitiveKeys.contains(matchingKey))
      {
         logger.info("[ihmc-build] Adding module: " + matchingKey)

         transitiveKeys.add(matchingKey)
         findTransitivesRecursive(buildNameToPathMap.get(matchingKey), transitiveKeys, buildNameToPathMap, projectNameReplacements)
      }
   }
}

String findMatchingBuildKey(String hyphenatedName, Map<String, java.nio.file.Path> map, Map<String, String> projectNameReplacements)
{
   String matched = null;
   for (String folderName : map.keySet())
   {
      if (matchNames(folderName, hyphenatedName, projectNameReplacements))
      {
         matched = folderName
      }
   }

   return matched
}

void mapDirectory(java.nio.file.Path directory, Map<String, java.nio.file.Path> map)
{
   Files.list(directory).forEach {
      if (Files.isDirectory(it) && Files.exists(it.resolve("build.gradle")))
      {
         map.put(it.fileName.toString(), it)
         mapDirectory(it, map)
      }
   }
}

boolean matchNames(String directoryName, String buildName, Map<String, String> projectNameReplacements)
{
   if (directoryName == buildName) return true
   if (directoryName == hyphenatedToPascalCased(buildName, projectNameReplacements)) return true

   if (buildName.contains("-"))
   {
      String possibleMainProject = buildName.substring(0, buildName.lastIndexOf("-"))
      if (possibleMainProject != buildName)
      {
         if (directoryName == possibleMainProject) return true
         if (directoryName == hyphenatedToPascalCased(possibleMainProject, projectNameReplacements)) return true
      }
   }

   return false
}

SortedSet<String> parseDependenciesFromGradleFile(java.nio.file.Path buildFile)
{
   SortedSet<String> dependencySet = new TreeSet<String>()
   try
   {
      AstBuilder builder = new AstBuilder()
      def bytesInFile = new String(Files.readAllBytes(buildFile))
      logger.info("[ihmc-build] Parsing for dependencies: " + buildFile)
      List<ASTNode> nodes = builder.buildFromString(bytesInFile)
      List<String[]> dependencies = new ArrayList<>()
      def visitor = codeVisitor(dependencies)
      for (ASTNode node : nodes)
      {
         node.visit(visitor)
      }

      dependencies.each {
         if (it[0] == "us.ihmc")
         {
            logger.info("[ihmc-build] Found declared us.ihmc dependency: " + it[1])
            dependencySet.add(it[1])
         }
      }
   }
   catch (NoSuchFileException e)
   {
      logger.info("[ihmc-build] Build not found on disk: " + e.getMessage())
   }
   catch (GradleScriptException e)
   {
      logger.error("[ihmc-build] Cannot evaluate " + buildFile + ": " + e.getMessage())
   }
   catch (MultipleCompilationErrorsException e)
   {
      logger.error("[ihmc-build] Cannot evaluate " + buildFile + ": " + e.getMessage())
   }
   catch (IOException e)
   {
      logger.error(e.printStackTrace())
   }
   return dependencySet
}

private CodeVisitorSupport codeVisitor(dependencies)
{
   return new CodeVisitorSupport() {
      void visitArgumentlistExpression(ArgumentListExpression ale)
      {
         List<Expression> expressions = ale.getExpressions()

         if (expressions.size() == 1 && expressions.get(0) instanceof ConstantExpression)
         {
            String dependencyString = expressions.get(0).getText()
            if (dependencyString.contains(":"))
            {
               String[] split = dependencyString.split(":")

               if (split.length >= 3)
               {
                  dependencies.add([split[0], split[1], split[2]])
               }
            }
         }

         super.visitArgumentlistExpression(ale)
      }

      void visitMapExpression(MapExpression expression)
      {
         logger.info("[ihmc-build] Found map entry: " + expression.getText())
         List<MapEntryExpression> mapEntryExpressions = expression.getMapEntryExpressions()
         if (mapEntryExpressions.size() >= 3)
         {
            Map<String, String> dependencyMap = new HashMap<String, String>()

            for (MapEntryExpression mapEntryExpression : mapEntryExpressions)
            {
               String key = mapEntryExpression.getKeyExpression().getText()
               String value = mapEntryExpression.getValueExpression().getText()
               dependencyMap.put(key, value)
            }

            dependencies.add([dependencyMap.get("group"), dependencyMap.get("name"), dependencyMap.get("version")])
         }

         super.visitMapExpression(expression)
      }
   }
}

String hyphenatedToPascalCased(String hyphenated, Map<String, String> projectNameReplacements)
{
   String[] split = hyphenated.split("-")
   String pascalCased = ""
   for (String section : split)
   {
      if (projectNameReplacements.containsKey(section))
      {
         pascalCased += projectNameReplacements.get(section)
      } else
      {
         pascalCased += capitalize(section)
      }
   }
   return pascalCased
}

String capitalize(final String str)
{
   int strLen
   if (str == null || (strLen = str.length()) == 0)
   {
      return str
   }

   final char firstChar = str.charAt(0)
   if (Character.isTitleCase(firstChar))
   {
      return str
   }

   return new StringBuilder(strLen).append(Character.toTitleCase(firstChar)).append(str.substring(1)).toString()
}

Map projectNameReplacements()
{
   def projectNameReplacements = [:]
   projectNameReplacements["ihmc"] = "IHMC"
   projectNameReplacements["vt"] = "VT"
   projectNameReplacements["javafx"] = "JavaFX"
   projectNameReplacements["jmonkey"] = "JMonkey"
   projectNameReplacements["ros"] = "ROS"
   projectNameReplacements["ros1"] = "ROS1"
   projectNameReplacements["ros2"] = "ROS2"
   projectNameReplacements["lla"] = "LLA"
   projectNameReplacements["devops"] = "DevOps"
   projectNameReplacements["ejml"] = "EJML"
   projectNameReplacements["icub"] = "ICub"
   projectNameReplacements["dds"] = "DDS"
   projectNameReplacements["rtps"] = "RTPS"
   projectNameReplacements["sri"] = "SRI"
   projectNameReplacements["ethercat"] = "EtherCAT"
   projectNameReplacements["imu"] = "IMU"
   projectNameReplacements["icp"] = "ICP"
   projectNameReplacements["it"] = "IT"
   projectNameReplacements["ipxe"] = "IPXE"
   projectNameReplacements["aot"] = "AOT"
   projectNameReplacements["joctomap"] = "JOctoMap"
   projectNameReplacements["mav"] = "MAV"
   projectNameReplacements["megabots"] = "MegaBots"
   projectNameReplacements["megabot"] = "MegaBot"
   return projectNameReplacements
}
